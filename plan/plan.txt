my behavior tree implementation to fill in gaps and issues I found with other implementations

Notes:
-keep all export variables public in case users wish to access from other scripts
-if a node emits an editor warning in _get_configuration_warnings, don't repeat the warning at run time somewhere else
-avoid asserting, prefer throwing warnings and accounting for errors instead of crashing

Resources:
https://nodecanvas.paradoxnotion.com/documentation/?section=bt-nodes-reference
https://www.gamedeveloper.com/programming/behavior-trees-for-ai-how-they-work

Stage 1:
[X] essential nodes and tick system
[X] nodes receive enter, exit, interrupt and tick
[X] templates for node and service

[X]conditional abort should be a feature of the compositor, allowing it to interupt low priority nodes or self when its first conditional child returns Success
see https://www.youtube.com/watch?v=GFsK5x6ZW7k
https://opsive.com/support/documentation/behavior-designer/conditional-aborts/

[X] services, can be attached to a composite but unlike conditional aborts, they can't interrupt the tree, instead they run parallel shared code like contact damage while an enemy does different attacks
services nodes must be placed before other children

[X] handle tree pausing

node names are ugly with all the bt_ stuff, need a balance between readability and organizing

[X] make tree inherite bt_node
tick rate (how many frames between ticks)

[X]base class for composites and decorators for common code :)

[..] configuration warnings (composites and decorators left) and tool for all nodes

nodes:
[X] -wait for some time (min-max)
[X] -blackboard write, erase, check value
[X] -randomized sequence & selector


Stage 2:
nodes:
-reactive sequence & selector
[X]-simple parallel
-common leaves (play animation, play sound etc..)

incorporate events, we can have nodes like a signal sequence that only runs when a signal it's listening to fire in which case it interrupt low priority nodes

make into plugin and set nodes to appear in the Add Child menu

document exports and short descrption for each node

unit tests:
-all node types and their expected behavior
-blackboard
-conditional aborts
-forcing a path from any node to any other
-pausing/unpausing
-changing tree nodes at run-time
-practical example

support sub-trees and shared/multiple blackboards

[-] dynamic tree, support run-time modifications

plugin for visualizing tree graph and monitors at run-time,
support placing breakpoints on a specific node in the graph
use node name and editor description for the graph

Stage 3:
documentations
example scenes and projects

icons
asset lib setup

Stage 4 (future):
make into C++ module
translation
multiplayer support

